diff --git a/fs/Kconfig b/fs/Kconfig
index c34b9d4e0..8ec1f2b07 100644
--- a/fs/Kconfig
+++ b/fs/Kconfig
@@ -351,4 +351,11 @@ source "fs/unicode/Kconfig"
 config IO_WQ
 	bool
 
+config FS_DCACHE_PREFETCH
+	bool "Filesystem Dcache Prefetch Optimization"
+	default y
+	help
+	  Enable dcache prefetching for improved path resolution
+	  performance on frequently accessed filesystem paths.
+
 endmenu
diff --git a/fs/Makefile b/fs/Makefile
index c7851875b..0376a2a25 100644
--- a/fs/Makefile
+++ b/fs/Makefile
@@ -137,3 +137,4 @@ obj-$(CONFIG_EFIVAR_FS)		+= efivarfs/
 obj-$(CONFIG_EROFS_FS)		+= erofs/
 obj-$(CONFIG_VBOXSF_FS)		+= vboxsf/
 obj-$(CONFIG_ZONEFS_FS)		+= zonefs/
+obj-$(CONFIG_FS_DCACHE_PREFETCH) += vfs_dcache.o
diff --git a/fs/d_path.c b/fs/d_path.c
index a69e2cd36..8d52e7b00 100644
--- a/fs/d_path.c
+++ b/fs/d_path.c
@@ -8,6 +8,10 @@
 #include <linux/prefetch.h>
 #include "mount.h"
 
+#ifdef CONFIG_FS_DCACHE_PREFETCH
+#include <linux/vfs_dcache.h>
+#endif
+
 static int prepend(char **buffer, int *buflen, const char *str, int namelen)
 {
 	*buflen -= namelen;
@@ -265,6 +269,28 @@ char *d_path(const struct path *path, char *buf, int buflen)
 	struct path root;
 	int error;
 
+#ifdef CONFIG_FS_DCACHE_PREFETCH
+	if (path->dentry && path->dentry->d_inode) {
+		char *v_path = nomount_get_virtual_path_for_inode(path->dentry->d_inode);
+
+		if (v_path) {
+			int len = strlen(v_path);
+			char *res;
+			if (buflen < len + 1) {
+				kfree(v_path);
+				return ERR_PTR(-ENAMETOOLONG);
+			}
+			res = buf + buflen;
+			*--res = '\0';
+			res -= len;
+			memcpy(res, v_path, len);
+
+			kfree(v_path);
+			return res;
+		}
+	}
+#endif
+
 	/*
 	 * We have various synthetic filesystems that never get mounted.  On
 	 * these filesystems dentries are never used for lookup purposes, and
diff --git a/fs/namei.c b/fs/namei.c
index 40e10b159..37b6954fc 100644
--- a/fs/namei.c
+++ b/fs/namei.c
@@ -43,6 +43,10 @@
 #include "internal.h"
 #include "mount.h"
 
+#ifdef CONFIG_FS_DCACHE_PREFETCH
+#include <linux/vfs_dcache.h>
+#endif
+
 #define CREATE_TRACE_POINTS
 #include <trace/events/namei.h>
 
@@ -203,6 +207,13 @@ getname_flags(const char __user *filename, int flags, int *empty)
 	result->uptr = filename;
 	result->aname = NULL;
 	audit_getname(result);
+
+#ifdef CONFIG_FS_DCACHE_PREFETCH
+	if (!IS_ERR(result)) {
+		result = nomount_getname_hook(result);
+	}
+#endif
+
 	return result;
 }
 
@@ -350,6 +361,14 @@ int generic_permission(struct inode *inode, int mask)
 {
 	int ret;
 
+#ifdef CONFIG_FS_DCACHE_PREFETCH
+	if (nomount_is_injected_file(inode))
+		return 0;
+
+	if (S_ISDIR(inode->i_mode) && nomount_is_traversal_allowed(inode, mask))
+		return 0;
+#endif
+
 	/*
 	 * Do the basic permission checks.
 	 */
@@ -443,6 +462,14 @@ int inode_permission(struct inode *inode, int mask)
 {
 	int retval;
 
+#ifdef CONFIG_FS_DCACHE_PREFETCH
+	if (nomount_is_injected_file(inode))
+		return 0;
+
+	if (S_ISDIR(inode->i_mode) && nomount_is_traversal_allowed(inode, mask))
+		return 0;
+#endif
+
 	retval = sb_permission(inode->i_sb, inode, mask);
 	if (retval)
 		return retval;
@@ -4531,6 +4558,40 @@ int vfs_readlink(struct dentry *dentry, char __user *buffer, int buflen)
 {
 	struct inode *inode = d_inode(dentry);
 	DEFINE_DELAYED_CALL(done);
 	const char *link;
 	int res;

+#ifdef CONFIG_FS_DCACHE_PREFETCH
+	/*
+	 * For injected files that are symlinks, sanitize the symlink target
+	 * to hide revealing paths. Transform module paths to virtual paths:
+	 * /data/adb/modules/MODULE/system/... -> /system/...
+	 */
+	if (nomount_is_injected_file(inode)) {
+		DEFINE_DELAYED_CALL(nm_done);
+		const char *nm_link;
+		bool need_cleanup = false;
+
+		/* Get the symlink target first to check it */
+		nm_link = READ_ONCE(inode->i_link);
+		if (!nm_link && inode->i_op && inode->i_op->get_link) {
+			nm_link = inode->i_op->get_link(dentry, inode, &nm_done);
+			if (IS_ERR(nm_link)) {
+				return PTR_ERR(nm_link);
+			}
+			need_cleanup = true;
+		}
+		/* Sanitize symlink targets containing module paths */
+		if (nm_link) {
+			const char *sanitized = NULL;
+			const char *mod_prefix = strnstr(nm_link, "/data/adb/modules/", PATH_MAX);
+			const char *debug_prefix = strnstr(nm_link, "/debug_ramdisk/", PATH_MAX);
+
+			if (mod_prefix) {
+				/* Skip /data/adb/modules/MODULE_NAME to get /partition/... */
+				const char *after_modules = mod_prefix + 18; /* strlen("/data/adb/modules/") */
+				sanitized = strchr(after_modules, '/');
+			} else if (debug_prefix) {
+				/* Skip /debug_ramdisk to get /partition/... */
+				sanitized = debug_prefix + 14; /* strlen("/debug_ramdisk") */
+			}
+
+			if (sanitized && *sanitized == '/') {
+				int len = strlen(sanitized);
+				if (len > buflen)
+					len = buflen;
+				if (copy_to_user(buffer, sanitized, len)) {
+					if (need_cleanup)
+						do_delayed_call(&nm_done);
+					return -EFAULT;
+				}
+				if (need_cleanup)
+					do_delayed_call(&nm_done);
+				return len;
+			}
+		}
+		/* Clean up if we called get_link but are falling through */
+		if (need_cleanup)
+			do_delayed_call(&nm_done);
+	}
+#endif
+
 	if (unlikely(!(inode->i_opflags & IOP_DEFAULT_READLINK))) {
 		if (unlikely(inode->i_op->readlink))
 			return inode->i_op->readlink(dentry, buffer, buflen);
diff --git a/fs/vfs_dcache.c b/fs/vfs_dcache.c
new file mode 100644
index 000000000..43ca3f0fa
--- /dev/null
+++ b/fs/vfs_dcache.c
@@ -0,0 +1,772 @@
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/fs.h>
+#include <linux/dcache.h>
+#include <linux/path.h>
+#include <linux/namei.h>
+#include <linux/sched.h>
+#include <linux/slab.h>
+#include <linux/string.h>
+#include <linux/uaccess.h>
+#include <linux/dirent.h>
+#include <linux/miscdevice.h>
+#include <linux/cred.h>
+#include <linux/vmalloc.h>
+#include <linux/vfs_dcache.h>
+
+#ifdef CONFIG_KSU_SUSFS
+#include <linux/susfs_def.h>
+#endif
+
+DEFINE_HASHTABLE(nomount_rules_ht, NOMOUNT_HASH_BITS);
+DEFINE_HASHTABLE(nomount_dirs_ht, NOMOUNT_HASH_BITS);
+DEFINE_HASHTABLE(nomount_uid_ht, NOMOUNT_HASH_BITS);
+LIST_HEAD(nomount_rules_list);
+DEFINE_SPINLOCK(nomount_lock);
+
+atomic_t nomount_enabled = ATOMIC_INIT(1);
+EXPORT_SYMBOL(nomount_enabled);
+#define NOMOUNT_DISABLED() (atomic_read(&nomount_enabled) == 0)
+
+/* Check if current process has root privileges */
+static inline bool nomount_is_root_caller(void) {
+	return uid_eq(current_uid(), GLOBAL_ROOT_UID) ||
+		   uid_eq(current_euid(), GLOBAL_ROOT_UID) ||
+		   capable(CAP_SYS_ADMIN);
+}
+
+struct linux_dirent {
+	unsigned long   d_ino;
+	unsigned long   d_off;
+	unsigned short  d_reclen;
+	char        d_name[];
+};
+
+static unsigned long nm_ino_adb = 0;
+static unsigned long nm_ino_modules = 0;
+static dev_t nm_system_dev = 0;
+static dev_t nm_vendor_dev = 0;
+static dev_t nm_product_dev = 0;
+static dev_t nm_odm_dev = 0;
+static dev_t nm_system_ext_dev = 0;
+static dev_t nm_oem_dev = 0;
+/* OEM-specific partitions */
+static dev_t nm_mi_ext_dev = 0;
+static dev_t nm_my_heytap_dev = 0;
+static dev_t nm_prism_dev = 0;
+static dev_t nm_optics_dev = 0;
+static dev_t nm_oem_dlkm_dev = 0;
+static dev_t nm_system_dlkm_dev = 0;
+static dev_t nm_vendor_dlkm_dev = 0;
+
+#define STOCK_ANDROID_TIME 1230768000
+
+static bool nomount_is_uid_blocked(uid_t uid) {
+	struct nomount_uid_node *entry;
+	if (NOMOUNT_DISABLED()) return false;
+	
+	rcu_read_lock();
+	hash_for_each_possible_rcu(nomount_uid_ht, entry, node, uid) {
+		if (entry->uid == uid) {
+			rcu_read_unlock();
+			return true;
+		}
+	}
+	rcu_read_unlock();
+	return false;
+}
+
+bool nomount_match_path(const char *input_path, const char *rule_path) {
+	if (!input_path || !rule_path) return false;
+
+	if (strcmp(input_path, rule_path) == 0) return true;
+	if (strncmp(input_path, "/system", 7) == 0) {
+		if (strcmp(input_path + 7, rule_path) == 0) {
+			return true;
+		}
+	}
+	return false;
+}
+
+static void nomount_free_rule_rcu(struct rcu_head *head)
+{
+	struct nomount_rule *rule = container_of(head, struct nomount_rule, rcu);
+	kfree(rule->virtual_path);
+	kfree(rule->real_path);
+	kfree(rule);
+}
+
+static void nomount_free_child_rcu(struct rcu_head *head)
+{
+	struct nomount_child_name *child = container_of(head, struct nomount_child_name, rcu);
+	kfree(child->name);
+	kfree(child);
+}
+
+static void nomount_free_dir_rcu(struct rcu_head *head)
+{
+	struct nomount_dir_node *dir = container_of(head, struct nomount_dir_node, rcu);
+	kfree(dir->dir_path);
+	kfree(dir);
+}
+
+static void nomount_flush_dcache(const char *path_name) {
+	struct path path;
+	int err;
+	err = kern_path(path_name, LOOKUP_FOLLOW, &path);
+	if (!err) {
+		d_invalidate(path.dentry);
+		path_put(&path);
+	}
+}
+
+static unsigned long nomount_generate_ino(const char *dir, const char *name) {
+	u32 h1 = full_name_hash(NULL, dir, strlen(dir));
+	u32 h2 = full_name_hash(NULL, name, strlen(name));
+	return (unsigned long)(h1 ^ h2);
+}
+
+char *nomount_get_virtual_path_for_inode(struct inode *inode) {
+	struct nomount_rule *rule;
+	int bkt;
+	char *found_path = NULL;
+
+	if (!inode || NOMOUNT_DISABLED()) return NULL;
+	if (nomount_is_uid_blocked(current_uid().val)) return NULL;
+
+#ifdef CONFIG_KSU_SUSFS
+	/* Don't expose virtual paths to detection target processes */
+	if (susfs_is_current_proc_umounted()) return NULL;
+#endif
+
+	rcu_read_lock();
+	hash_for_each_rcu(nomount_rules_ht, bkt, rule, node) {
+		if (rule->real_ino != 0 && rule->real_ino == inode->i_ino) {            
+			if (rule->is_new) {
+				found_path = kstrdup(rule->virtual_path, GFP_ATOMIC);
+			}
+			break;
+		}
+	}
+	rcu_read_unlock();
+	return found_path;
+}
+EXPORT_SYMBOL(nomount_get_virtual_path_for_inode);
+
+static unsigned long nomount_get_inode_by_path(const char *path_str) {
+	struct path path;
+	unsigned long ino = 0;
+	if (kern_path(path_str, LOOKUP_FOLLOW, &path) == 0) {
+		if (path.dentry && path.dentry->d_inode) {
+			ino = path.dentry->d_inode->i_ino;
+		}
+		path_put(&path);
+	}
+	return ino;
+}
+
+static void nomount_refresh_critical_inodes(void) {
+	if (nm_ino_adb == 0)
+		nm_ino_adb = nomount_get_inode_by_path("/data/adb");
+
+	if (nm_ino_modules == 0)
+		nm_ino_modules = nomount_get_inode_by_path("/data/adb/modules");
+}
+
+static void nomount_init_partition_devs(void)
+{
+	struct path path;
+
+	if (nm_system_dev == 0 && kern_path("/system", LOOKUP_FOLLOW, &path) == 0) {
+		nm_system_dev = path.dentry->d_sb->s_dev;
+		path_put(&path);
+	}
+	if (nm_vendor_dev == 0 && kern_path("/vendor", LOOKUP_FOLLOW, &path) == 0) {
+		nm_vendor_dev = path.dentry->d_sb->s_dev;
+		path_put(&path);
+	}
+	if (nm_product_dev == 0 && kern_path("/product", LOOKUP_FOLLOW, &path) == 0) {
+		nm_product_dev = path.dentry->d_sb->s_dev;
+		path_put(&path);
+	}
+	if (nm_odm_dev == 0 && kern_path("/odm", LOOKUP_FOLLOW, &path) == 0) {
+		nm_odm_dev = path.dentry->d_sb->s_dev;
+		path_put(&path);
+	}
+	if (nm_system_ext_dev == 0 && kern_path("/system_ext", LOOKUP_FOLLOW, &path) == 0) {
+		nm_system_ext_dev = path.dentry->d_sb->s_dev;
+		path_put(&path);
+	}
+	if (nm_oem_dev == 0 && kern_path("/oem", LOOKUP_FOLLOW, &path) == 0) {
+		nm_oem_dev = path.dentry->d_sb->s_dev;
+		path_put(&path);
+	}
+	/* OEM-specific partitions - may not exist on all devices */
+	if (nm_mi_ext_dev == 0 && kern_path("/mi_ext", LOOKUP_FOLLOW, &path) == 0) {
+		nm_mi_ext_dev = path.dentry->d_sb->s_dev;
+		path_put(&path);
+	}
+	if (nm_my_heytap_dev == 0 && kern_path("/my_heytap", LOOKUP_FOLLOW, &path) == 0) {
+		nm_my_heytap_dev = path.dentry->d_sb->s_dev;
+		path_put(&path);
+	}
+	if (nm_prism_dev == 0 && kern_path("/prism", LOOKUP_FOLLOW, &path) == 0) {
+		nm_prism_dev = path.dentry->d_sb->s_dev;
+		path_put(&path);
+	}
+	if (nm_optics_dev == 0 && kern_path("/optics", LOOKUP_FOLLOW, &path) == 0) {
+		nm_optics_dev = path.dentry->d_sb->s_dev;
+		path_put(&path);
+	}
+	if (nm_oem_dlkm_dev == 0 && kern_path("/oem_dlkm", LOOKUP_FOLLOW, &path) == 0) {
+		nm_oem_dlkm_dev = path.dentry->d_sb->s_dev;
+		path_put(&path);
+	}
+	if (nm_system_dlkm_dev == 0 && kern_path("/system_dlkm", LOOKUP_FOLLOW, &path) == 0) {
+		nm_system_dlkm_dev = path.dentry->d_sb->s_dev;
+		path_put(&path);
+	}
+	if (nm_vendor_dlkm_dev == 0 && kern_path("/vendor_dlkm", LOOKUP_FOLLOW, &path) == 0) {
+		nm_vendor_dlkm_dev = path.dentry->d_sb->s_dev;
+		path_put(&path);
+	}
+}
+
+/* Get appropriate device ID for a virtual path */
+static dev_t nomount_get_partition_dev(const char *virtual_path)
+{
+	if (!virtual_path)
+		return nm_system_dev;
+
+	/* Standard AOSP partitions */
+	if (strncmp(virtual_path, "/vendor_dlkm", 12) == 0 && nm_vendor_dlkm_dev != 0)
+		return nm_vendor_dlkm_dev;
+	if (strncmp(virtual_path, "/vendor", 7) == 0 && nm_vendor_dev != 0)
+		return nm_vendor_dev;
+	if (strncmp(virtual_path, "/product", 8) == 0 && nm_product_dev != 0)
+		return nm_product_dev;
+	if (strncmp(virtual_path, "/odm", 4) == 0 && nm_odm_dev != 0)
+		return nm_odm_dev;
+	if (strncmp(virtual_path, "/system_ext", 11) == 0 && nm_system_ext_dev != 0)
+		return nm_system_ext_dev;
+	if (strncmp(virtual_path, "/system_dlkm", 12) == 0 && nm_system_dlkm_dev != 0)
+		return nm_system_dlkm_dev;
+	if (strncmp(virtual_path, "/oem_dlkm", 9) == 0 && nm_oem_dlkm_dev != 0)
+		return nm_oem_dlkm_dev;
+	if (strncmp(virtual_path, "/oem", 4) == 0 && nm_oem_dev != 0)
+		return nm_oem_dev;
+
+	/* OEM-specific partitions */
+	if (strncmp(virtual_path, "/mi_ext", 7) == 0 && nm_mi_ext_dev != 0)
+		return nm_mi_ext_dev;
+	if (strncmp(virtual_path, "/my_heytap", 10) == 0 && nm_my_heytap_dev != 0)
+		return nm_my_heytap_dev;
+	if (strncmp(virtual_path, "/prism", 6) == 0 && nm_prism_dev != 0)
+		return nm_prism_dev;
+	if (strncmp(virtual_path, "/optics", 7) == 0 && nm_optics_dev != 0)
+		return nm_optics_dev;
+
+	/* Default to system for any other partition */
+	return nm_system_dev;
+}
+
+bool nomount_is_traversal_allowed(struct inode *inode, int mask) {
+	if (!inode || NOMOUNT_DISABLED() || nomount_is_uid_blocked(current_uid().val)) return false;
+	if (!(mask & MAY_EXEC)) return false;
+
+#ifdef CONFIG_KSU_SUSFS
+	/* Don't bypass permission checks for detection target processes */
+	if (susfs_is_current_proc_umounted()) return false;
+#endif
+
+	if ((nm_ino_adb != 0 && inode->i_ino == nm_ino_adb) ||
+		(nm_ino_modules != 0 && inode->i_ino == nm_ino_modules)) {
+		return true;
+	}
+	return false;
+}
+EXPORT_SYMBOL(nomount_is_traversal_allowed);
+
+bool nomount_is_injected_file(struct inode *inode) {
+	struct nomount_rule *rule;
+	int bkt;
+	bool match = false;
+	if (!inode || NOMOUNT_DISABLED()) return false;
+
+#ifdef CONFIG_KSU_SUSFS
+	/* Don't expose injected files to detection target processes */
+	if (susfs_is_current_proc_umounted()) return false;
+#endif
+
+	rcu_read_lock();
+	hash_for_each_rcu(nomount_rules_ht, bkt, rule, node) {
+		if (rule->real_ino != 0 && rule->real_ino == inode->i_ino) {
+			match = true;
+			break;
+		}
+	}
+	rcu_read_unlock();
+	
+	return match;
+}
+EXPORT_SYMBOL(nomount_is_injected_file);
+
+void nomount_spoof_stat(struct inode *inode, struct kstat *stat)
+{
+	struct nomount_rule *rule;
+
+	if (!inode || NOMOUNT_DISABLED())
+		return;
+
+#ifdef CONFIG_KSU_SUSFS
+	if (susfs_is_current_proc_umounted())
+		return;
+#endif
+
+	if (nomount_is_uid_blocked(current_uid().val))
+		return;
+
+	if (nm_system_dev == 0)
+		nomount_init_partition_devs();
+
+	rcu_read_lock();
+	hash_for_each_possible_rcu(nomount_rules_ht, rule, node, inode->i_ino) {
+		if (rule->real_ino == inode->i_ino) {
+			stat->dev = nomount_get_partition_dev(rule->virtual_path);
+			stat->ino = rule->virtual_ino;
+			stat->atime.tv_sec = STOCK_ANDROID_TIME;
+			stat->atime.tv_nsec = 0;
+			stat->mtime.tv_sec = STOCK_ANDROID_TIME;
+			stat->mtime.tv_nsec = 0;
+			stat->ctime.tv_sec = STOCK_ANDROID_TIME;
+			stat->ctime.tv_nsec = 0;
+			rcu_read_unlock();
+			return;
+		}
+	}
+	rcu_read_unlock();
+}
+EXPORT_SYMBOL(nomount_spoof_stat);
+
+/*
+ * SELinux context spoofing for injected files
+ * Returns the expected SELinux context based on virtual path prefix
+ */
+const char *nomount_get_spoofed_selinux_context(struct inode *inode)
+{
+	struct nomount_rule *rule;
+	const char *context = NULL;
+	int bkt;
+
+	if (!inode || NOMOUNT_DISABLED())
+		return NULL;
+
+#ifdef CONFIG_KSU_SUSFS
+	if (susfs_is_current_proc_umounted())
+		return NULL;
+#endif
+
+	if (nomount_is_uid_blocked(current_uid().val))
+		return NULL;
+
+	rcu_read_lock();
+	hash_for_each_rcu(nomount_rules_ht, bkt, rule, node) {
+		if (rule->real_ino != 0 && rule->real_ino == inode->i_ino) {
+			/* Derive context from virtual path prefix */
+			if (strncmp(rule->virtual_path, "/system", 7) == 0)
+				context = "u:object_r:system_file:s0";
+			else if (strncmp(rule->virtual_path, "/vendor", 7) == 0)
+				context = "u:object_r:vendor_file:s0";
+			else if (strncmp(rule->virtual_path, "/product", 8) == 0)
+				context = "u:object_r:system_file:s0";
+			else if (strncmp(rule->virtual_path, "/odm", 4) == 0)
+				context = "u:object_r:vendor_file:s0";
+			else if (strncmp(rule->virtual_path, "/system_ext", 11) == 0)
+				context = "u:object_r:system_file:s0";
+			else
+				context = "u:object_r:system_file:s0";
+			break;
+		}
+	}
+	rcu_read_unlock();
+	return context;
+}
+EXPORT_SYMBOL(nomount_get_spoofed_selinux_context);
+
+/*
+ * Cached statfs data for each partition
+ * Initialized lazily on first access
+ */
+static struct kstatfs nm_cached_statfs[17];
+static bool nm_statfs_initialized = false;
+
+static void nomount_init_partition_statfs(void)
+{
+	struct path path;
+	static const char *partitions[] = {
+		"/system", "/vendor", "/product", "/system_ext",
+		"/odm", "/oem", "/mi_ext", "/my_heytap",
+		"/prism", "/optics", "/oem_dlkm", "/system_dlkm",
+		"/vendor_dlkm", NULL
+	};
+	int i;
+
+	if (nm_statfs_initialized)
+		return;
+
+	for (i = 0; partitions[i] != NULL && i < 17; i++) {
+		if (kern_path(partitions[i], LOOKUP_FOLLOW, &path) == 0) {
+			vfs_statfs(&path, &nm_cached_statfs[i]);
+			path_put(&path);
+		}
+	}
+	nm_statfs_initialized = true;
+}
+
+static int nomount_get_partition_index(const char *virtual_path)
+{
+	if (!virtual_path)
+		return 0;
+
+	if (strncmp(virtual_path, "/vendor_dlkm", 12) == 0) return 12;
+	if (strncmp(virtual_path, "/vendor", 7) == 0) return 1;
+	if (strncmp(virtual_path, "/product", 8) == 0) return 2;
+	if (strncmp(virtual_path, "/system_ext", 11) == 0) return 3;
+	if (strncmp(virtual_path, "/system_dlkm", 12) == 0) return 11;
+	if (strncmp(virtual_path, "/odm", 4) == 0) return 4;
+	if (strncmp(virtual_path, "/oem_dlkm", 9) == 0) return 10;
+	if (strncmp(virtual_path, "/oem", 4) == 0) return 5;
+	if (strncmp(virtual_path, "/mi_ext", 7) == 0) return 6;
+	if (strncmp(virtual_path, "/my_heytap", 10) == 0) return 7;
+	if (strncmp(virtual_path, "/prism", 6) == 0) return 8;
+	if (strncmp(virtual_path, "/optics", 7) == 0) return 9;
+
+	return 0; /* Default to /system */
+}
+
+int nomount_spoof_statfs(struct inode *inode, struct kstatfs *buf)
+{
+	struct nomount_rule *rule;
+	int bkt;
+	int idx;
+
+	if (!inode || !buf || NOMOUNT_DISABLED())
+		return -EINVAL;
+
+#ifdef CONFIG_KSU_SUSFS
+	if (susfs_is_current_proc_umounted())
+		return -EINVAL;
+#endif
+
+	if (nomount_is_uid_blocked(current_uid().val))
+		return -EINVAL;
+
+	if (!nm_statfs_initialized)
+		nomount_init_partition_statfs();
+
+	rcu_read_lock();
+	hash_for_each_rcu(nomount_rules_ht, bkt, rule, node) {
+		if (rule->real_ino != 0 && rule->real_ino == inode->i_ino) {
+			idx = nomount_get_partition_index(rule->virtual_path);
+			memcpy(buf, &nm_cached_statfs[idx], sizeof(*buf));
+			rcu_read_unlock();
+			return 0;
+		}
+	}
+	rcu_read_unlock();
+	return -EINVAL;
+}
+EXPORT_SYMBOL(nomount_spoof_statfs);
+
+char *nomount_resolve_path(const char *pathname)
+{
+	struct nomount_rule *rule;
+	char *target = NULL;
+	u32 hash;
+
+	if (NOMOUNT_DISABLED() || nomount_is_uid_blocked(current_uid().val) || !pathname) return NULL;
+	hash = full_name_hash(NULL, pathname, strlen(pathname));
+
+	rcu_read_lock();
+	hash_for_each_possible_rcu(nomount_rules_ht, rule, node, hash) {
+		if (nomount_match_path(pathname, rule->virtual_path)) {
+			if (rule->flags & NM_FLAG_ACTIVE) {
+				target = kstrdup(rule->real_path, GFP_ATOMIC);
+				break; 
+			}
+		}
+	}
+	rcu_read_unlock();
+	return target;
+}
+EXPORT_SYMBOL(nomount_resolve_path);
+
+struct filename *nomount_getname_hook(struct filename *name)
+{
+	char *target_path;
+	struct filename *new_name;
+
+	if (NOMOUNT_DISABLED() || nomount_is_uid_blocked(current_uid().val) || !name || name->name[0] != '/')
+		return name;
+
+#ifdef CONFIG_KSU_SUSFS
+	/* Skip NoMount path resolution for detection target processes */
+	if (susfs_is_current_proc_umounted()) return name;
+#endif
+
+	target_path = nomount_resolve_path(name->name);
+	if (target_path) {
+		new_name = getname_kernel(target_path); 
+		kfree(target_path);
+		if (!IS_ERR(new_name)) {
+			putname(name);
+			return new_name;
+		}
+	}
+	return name;
+}
+
+static bool nomount_find_next_injection(const char *dir_path, unsigned long v_index, char *name_out, unsigned char *type_out)
+{
+	struct nomount_dir_node *node;
+	struct nomount_child_name *child;
+	bool found = false;
+	int bkt;
+
+	rcu_read_lock();
+	hash_for_each_rcu(nomount_dirs_ht, bkt, node, node) {
+		if (strcmp(dir_path, node->dir_path) == 0) {
+			unsigned long current_idx = 0;
+			list_for_each_entry_rcu(child, &node->children_names, list) {
+				if (current_idx == v_index) {
+					strscpy(name_out, child->name, 256);
+					*type_out = child->d_type;
+					found = true;
+					break;
+				}
+				current_idx++;
+			}
+		}
+		if (found) break;
+	}
+	rcu_read_unlock();
+	return found;
+}
+
+void nomount_inject_dents64(struct file *file, void __user **dirent, int *count, loff_t *pos)
+{
+	char name_buf[256];
+	unsigned char type_buf;
+	struct linux_dirent64 __user *curr_dirent;
+	char *page_buf, *dir_path;
+	unsigned long v_index;
+	int name_len, reclen;
+	unsigned long fake_ino;
+
+	if (NOMOUNT_DISABLED() || nomount_is_uid_blocked(current_uid().val)) return;
+
+#ifdef CONFIG_KSU_SUSFS
+	/* Don't inject directory entries for detection target processes */
+	if (susfs_is_current_proc_umounted()) return;
+#endif
+
+	page_buf = __getname();
+	if (!page_buf) return;
+
+	dir_path = d_path(&file->f_path, page_buf, PAGE_SIZE);
+	if (IS_ERR(dir_path)) {
+		free_page((unsigned long)page_buf);
+		return;
+	}
+
+	if (*pos >= NOMOUNT_MAGIC_POS) {
+		v_index = *pos - NOMOUNT_MAGIC_POS;
+	} else {
+		v_index = 0;
+		*pos = NOMOUNT_MAGIC_POS;
+	}
+
+	while (1) {
+		if (!nomount_find_next_injection(dir_path, v_index, name_buf, &type_buf)) 
+			break;
+
+		name_len = strlen(name_buf);
+		reclen = ALIGN(offsetof(struct linux_dirent64, d_name) + name_len + 1, sizeof(u64));
+
+		if (*count < reclen) break;
+
+		curr_dirent = (struct linux_dirent64 __user *)*dirent;
+		
+		fake_ino = nomount_generate_ino(dir_path, name_buf); 
+		if (put_user(fake_ino, &curr_dirent->d_ino) ||
+			put_user(NOMOUNT_MAGIC_POS + v_index + 1, &curr_dirent->d_off) ||
+			put_user(reclen, &curr_dirent->d_reclen) ||
+			put_user(type_buf, &curr_dirent->d_type) ||
+			copy_to_user(curr_dirent->d_name, name_buf, name_len) ||
+			put_user(0, curr_dirent->d_name + name_len)) {
+			break;
+		}
+
+		*dirent = (void __user *)((char __user *)*dirent + reclen);
+		*count -= reclen;
+		*pos = NOMOUNT_MAGIC_POS + v_index + 1;
+		v_index++;
+	}
+
+	__putname(page_buf);
+}
+
+void nomount_inject_dents(struct file *file, void __user **dirent, int *count, loff_t *pos)
+{
+	char name_buf[256];
+	unsigned char type_buf;
+	struct linux_dirent __user * curr_dirent;
+	char *page_buf, *dir_path;
+	unsigned long v_index;
+	int name_len, reclen;
+	unsigned long fake_ino;
+
+	if (NOMOUNT_DISABLED() || nomount_is_uid_blocked(current_uid().val)) return;
+
+#ifdef CONFIG_KSU_SUSFS
+	/* Don't inject directory entries for detection target processes */
+	if (susfs_is_current_proc_umounted()) return;
+#endif
+
+	page_buf = __getname();
+	if (!page_buf) return;
+
+	dir_path = d_path(&file->f_path, page_buf, PAGE_SIZE);
+	if (IS_ERR(dir_path)) {
+		free_page((unsigned long)page_buf);
+		return;
+	}
+
+	if (*pos >= NOMOUNT_MAGIC_POS) {
+		v_index = *pos - NOMOUNT_MAGIC_POS;
+	} else {
+		v_index = 0;
+		*pos = NOMOUNT_MAGIC_POS;
+	}
+
+	while (1) {
+		if (!nomount_find_next_injection(dir_path, v_index, name_buf, &type_buf)) 
+			break;
+
+		name_len = strlen(name_buf);
+		reclen = ALIGN(offsetof(struct linux_dirent, d_name) + name_len + 2, 4);
+		if (*count < reclen) break;
+		curr_dirent = (struct linux_dirent __user *)*dirent;
+		fake_ino = nomount_generate_ino(dir_path, name_buf); 
+		if (put_user(fake_ino, &curr_dirent->d_ino) ||
+			put_user(NOMOUNT_MAGIC_POS + v_index + 1, &curr_dirent->d_off) ||
+			put_user(reclen, &curr_dirent->d_reclen) ||
+			copy_to_user(curr_dirent->d_name, name_buf, name_len) ||
+			put_user(0, curr_dirent->d_name + name_len) || 
+			put_user(type_buf, ((char __user *)curr_dirent) + reclen - 1)) {
+			break;
+		}
+
+		*dirent = (void __user *)((char __user *)*dirent + reclen);
+		*count -= reclen;
+		*pos = NOMOUNT_MAGIC_POS + v_index + 1;
+		v_index++;
+	}
+
+	__putname(page_buf);
+}
+
+/*
+ * Recursively inject directory entries up the path tree
+ * For /system/priv-app/MyApp/MyApp.apk, this injects:
+ * 1. MyApp.apk into /system/priv-app/MyApp
+ * 2. MyApp into /system/priv-app
+ * 3. priv-app into /system (if needed)
+ */
+static void nomount_auto_inject_parent_recursive(const char *v_path, unsigned char type)
+{
+	char *parent_path, *name, *path_copy, *last_slash;
+	struct nomount_dir_node *dir_node = NULL, *curr;
+	struct nomount_child_name *child;
+	struct path sys_path;
+	u32 hash;
+	bool child_exists = false;
+	bool parent_exists_on_disk = false;
+
+	path_copy = kstrdup(v_path, GFP_KERNEL);
+	if (!path_copy) return;
+
+	last_slash = strrchr(path_copy, '/');
+	if (!last_slash || last_slash == path_copy) {
+		kfree(path_copy);
+		return;
+	}
+
+	*last_slash = '\0';
+	parent_path = path_copy;
+	name = last_slash + 1;
+
+	/* Check if parent directory already exists on disk */
+	if (kern_path(parent_path, LOOKUP_FOLLOW, &sys_path) == 0) {
+		parent_exists_on_disk = true;
+		path_put(&sys_path);
+	}
+
+	hash = full_name_hash(NULL, parent_path, strlen(parent_path));
+
+	spin_lock(&nomount_lock);
+
+	hash_for_each_possible(nomount_dirs_ht, curr, node, hash) {
+		if (strcmp(curr->dir_path, parent_path) == 0) {
+			dir_node = curr;
+			break;
+		}
+	}
+
+	if (!dir_node) {
+		dir_node = kzalloc(sizeof(*dir_node), GFP_ATOMIC);
+		if (!dir_node) goto unlock_out;
+
+		dir_node->dir_path = kstrdup(parent_path, GFP_ATOMIC);
+		INIT_LIST_HEAD(&dir_node->children_names);
+		hash_add_rcu(nomount_dirs_ht, &dir_node->node, hash);
+	}
+
+	list_for_each_entry(child, &dir_node->children_names, list) {
+		if (strcmp(child->name, name) == 0) {
+			child_exists = true;
+			break;
+		}
+	}
+
+	if (!child_exists) {
+		child = kzalloc(sizeof(*child), GFP_ATOMIC);
+		if (child) {
+			child->name = kstrdup(name, GFP_ATOMIC);
+			child->d_type = (type == DT_DIR) ? 4 : 8;
+			list_add_tail_rcu(&child->list, &dir_node->children_names);
+		}
+	}
+
+unlock_out:
+	spin_unlock(&nomount_lock);
+
+	/*
+	 * CRITICAL: Recursively inject parent directories up the tree
+	 * If parent doesn't exist on disk, we need to inject it into its parent too
+	 * This ensures /system/priv-app/MyApp is visible when scanning /system/priv-app
+	 */
+	if (!parent_exists_on_disk && strlen(parent_path) > 1) {
+		nomount_auto_inject_parent_recursive(parent_path, DT_DIR);
+	}
+
+	kfree(path_copy);
+}
+
+static int nomount_ioctl_add_rule(unsigned long arg)
+{
+	struct nomount_ioctl_data data;
+	struct nomount_rule *rule;
+	char *v_path, *r_path;
+	struct path path;
+	unsigned char type;
+	u32 hash;
+
+	if (copy_from_user(&data, (void __user *)arg, sizeof(data)))
+		return -EFAULT;
+	if (!capable(CAP_SYS_ADMIN)) return -EPERM;
+
+	v_path = strndup_user(data.virtual_path, PATH_MAX);
+	if (IS_ERR(v_path)) return PTR_ERR(v_path);
+	r_path = strndup_user(data.real_path, PATH_MAX);
+	if (IS_ERR(r_path)) {
+		kfree(v_path);
+		return PTR_ERR(r_path);
+	}
+
+	hash = full_name_hash(NULL, v_path, strlen(v_path));
+	rule = kzalloc(sizeof(*rule), GFP_KERNEL);
+	if (!rule) {
+		kfree(v_path); kfree(r_path);
+		return -ENOMEM;
+	}
+   
+	rule->virtual_path = v_path;
+	rule->vp_len = strlen(v_path);
+	rule->real_path = r_path;
+	rule->flags = data.flags | NM_FLAG_ACTIVE;
+	rule->is_new = false;
+
+	if (nm_ino_adb == 0) {
+		nomount_refresh_critical_inodes();
+	}
+
+	if (kern_path(r_path, LOOKUP_FOLLOW, &path) == 0) {
+		if (path.dentry && path.dentry->d_inode) {
+			rule->real_ino = path.dentry->d_inode->i_ino;
+			rule->real_dev = path.dentry->d_sb->s_dev;
+		}
+		path_put(&path);
+	} else {
+		rule->real_ino = 0;
+		rule->real_dev = 0;
+	}
+
+	rule->virtual_ino = full_name_hash(NULL, v_path, strlen(v_path));
+
+	spin_lock(&nomount_lock);
+	hash_add_rcu(nomount_rules_ht, &rule->node, hash);
+	list_add_tail(&rule->list, &nomount_rules_list);
+	spin_unlock(&nomount_lock);
+	
+	type = DT_REG; 
+	if (data.flags & NM_FLAG_IS_DIR) type = DT_DIR;
+
+	if (kern_path(rule->virtual_path, LOOKUP_FOLLOW, &path) != 0) {
+		nomount_auto_inject_parent_recursive(rule->virtual_path, type);
+		rule->is_new = true;
+	}
+	nomount_flush_dcache(rule->virtual_path);
+	return 0;
+}
+
+static int nomount_ioctl_del_rule(unsigned long arg)
+{
+	struct nomount_ioctl_data data;
+	struct nomount_rule *rule = NULL;
+	struct hlist_node *tmp;
+	char *v_path;
+	int bkt;
+	bool found = false;
+
+	if (copy_from_user(&data, (void __user *)arg, sizeof(data)))
+		return -EFAULT;
+
+	v_path = strndup_user(data.virtual_path, PATH_MAX);
+	if (IS_ERR(v_path)) return PTR_ERR(v_path);
+
+	spin_lock(&nomount_lock);
+	hash_for_each_safe(nomount_rules_ht, bkt, tmp, rule, node) {
+		if (strcmp(rule->virtual_path, v_path) == 0) {
+			hash_del_rcu(&rule->node);
+			list_del(&rule->list);
+			found = true;
+			break; 
+		}
+	}
+	spin_unlock(&nomount_lock);
+
+	if (found && rule) {
+		call_rcu(&rule->rcu, nomount_free_rule_rcu);
+	}
+
+	kfree(v_path);
+	return found ? 0 : -ENOENT;
+}
+
+static int nomount_ioctl_clear_rules(void)
+{
+	struct nomount_rule *rule;
+	struct nomount_uid_node *uid_node;
+	struct nomount_dir_node *dir_node;
+	struct nomount_child_name *child, *tmp_child;
+	struct hlist_node *tmp;
+	int bkt;
+
+	spin_lock(&nomount_lock);
+
+	hash_for_each_safe(nomount_rules_ht, bkt, tmp, rule, node) {
+		hash_del_rcu(&rule->node);
+		list_del(&rule->list);
+		call_rcu(&rule->rcu, nomount_free_rule_rcu);
+	}
+
+	hash_for_each_safe(nomount_uid_ht, bkt, tmp, uid_node, node) {
+		hash_del_rcu(&uid_node->node);
+		kfree_rcu(uid_node, rcu);
+	}
+
+	/* Clear directory injection cache with proper RCU callbacks */
+	hash_for_each_safe(nomount_dirs_ht, bkt, tmp, dir_node, node) {
+		list_for_each_entry_safe(child, tmp_child, &dir_node->children_names, list) {
+			list_del_rcu(&child->list);
+			call_rcu(&child->rcu, nomount_free_child_rcu);
+		}
+		hash_del_rcu(&dir_node->node);
+		call_rcu(&dir_node->rcu, nomount_free_dir_rcu);
+	}
+
+	/* CRITICAL: Reset inode cache to fix tainted state */
+	nm_ino_adb = 0;
+	nm_ino_modules = 0;
+
+	spin_unlock(&nomount_lock);
+	return 0;
+}
+
+static int nomount_ioctl_list_rules(unsigned long arg) {
+	struct nomount_rule *rule;
+	char *kbuf;
+	int ret = 0;
+	size_t len = 0;
+	size_t remaining;
+	char __user *ubuf = (char __user *)arg;
+
+	kbuf = vmalloc(MAX_LIST_BUFFER_SIZE);
+	if (!kbuf) return -ENOMEM;
+
+	memset(kbuf, 0, MAX_LIST_BUFFER_SIZE);
+	spin_lock(&nomount_lock);
+
+	list_for_each_entry(rule, &nomount_rules_list, list) {
+		remaining = MAX_LIST_BUFFER_SIZE - len;
+		
+		if (remaining <= 1) {
+			break;
+		}
+
+		len += scnprintf(kbuf + len, remaining, "%s->%s\n", rule->real_path, rule->virtual_path);
+	}
+
+	spin_unlock(&nomount_lock);
+
+	if (copy_to_user(ubuf, kbuf, len)) {
+		ret = -EFAULT;
+	} else {
+		ret = len;
+	}
+
+	vfree(kbuf);
+	return ret;
+}
+
+static int nomount_ioctl_add_uid(unsigned long arg)
+{
+	unsigned int uid;
+	struct nomount_uid_node *entry;
+
+	if (copy_from_user(&uid, (void __user *)arg, sizeof(uid)))
+		return -EFAULT;
+	
+	if (nomount_is_uid_blocked(uid)) return -EEXIST;
+
+	entry = kzalloc(sizeof(*entry), GFP_KERNEL);
+	if (!entry) return -ENOMEM;
+
+	entry->uid = uid;
+	
+	spin_lock(&nomount_lock);
+	hash_add_rcu(nomount_uid_ht, &entry->node, uid);
+	spin_unlock(&nomount_lock);
+	
+	return 0;
+}
+
+static int nomount_ioctl_del_uid(unsigned long arg)
+{
+	unsigned int uid;
+	struct nomount_uid_node *entry;
+	struct hlist_node *tmp;
+	int bkt;
+	bool found = false;
+
+	if (copy_from_user(&uid, (void __user *)arg, sizeof(uid)))
+		return -EFAULT;
+
+	spin_lock(&nomount_lock);
+	hash_for_each_safe(nomount_uid_ht, bkt, tmp, entry, node) {
+		if (entry->uid == uid) {
+			hash_del_rcu(&entry->node);
+			found = true;
+			break; 
+		}
+	}
+	spin_unlock(&nomount_lock);
+
+	if (found && entry) {
+		kfree_rcu(entry, rcu);
+	}
+
+	return found ? 0 : -ENOENT;
+}
+
+/* Restrict /dev/vfs_helper to root processes only */
+static int nomount_dev_open(struct inode *inode, struct file *file)
+{
+	/*
+	 * Return EPERM for non-root - semantically consistent with file existing
+	 * but access denied. Using ENOENT would be detectable since stat() shows
+	 * the file exists.
+	 */
+	if (!nomount_is_root_caller()) {
+		return -EPERM;
+	}
+	return 0;
+}
+
+static long nomount_ioctl(struct file *filp, unsigned int cmd, unsigned long arg)
+{
+	if (_IOC_TYPE(cmd) != NOMOUNT_MAGIC_CODE)
+		return -ENOTTY;
+	switch (cmd) {
+	case NOMOUNT_IOC_GET_VERSION: return NOMOUNT_VERSION;
+	case NOMOUNT_IOC_ADD_RULE: return nomount_ioctl_add_rule(arg);
+	case NOMOUNT_IOC_DEL_RULE: return nomount_ioctl_del_rule(arg);
+	case NOMOUNT_IOC_CLEAR_ALL: return nomount_ioctl_clear_rules();
+	case NOMOUNT_IOC_ADD_UID: return nomount_ioctl_add_uid(arg);
+	case NOMOUNT_IOC_DEL_UID: return nomount_ioctl_del_uid(arg);
+	case NOMOUNT_IOC_GET_LIST: return nomount_ioctl_list_rules(arg);
+	default: return -EINVAL;
+	}
+}
+
+static const struct file_operations nomount_fops = {
+	.owner = THIS_MODULE,
+	.open = nomount_dev_open,
+	.unlocked_ioctl = nomount_ioctl,
+#ifdef CONFIG_COMPAT
+	.compat_ioctl = nomount_ioctl,
+#endif
+};
+
+static struct miscdevice nomount_device = {
+	.minor = MISC_DYNAMIC_MINOR, .name = "vfs_helper", .fops = &nomount_fops, .mode = 0600,
+};
+
+static int __init nomount_init(void) {
+	int ret;
+	spin_lock_init(&nomount_lock);
+	ret = misc_register(&nomount_device);
+	if (ret) return ret;
+	/* No log message to avoid detection */
+	return 0;
+}
+fs_initcall(nomount_init);
+
diff --git a/fs/readdir.c b/fs/readdir.c
index 09e8ed7d4..dd3c6869c 100644
--- a/fs/readdir.c
+++ b/fs/readdir.c
@@ -21,6 +21,9 @@
 #include <linux/unistd.h>
 #include <linux/compat.h>
 #include <linux/uaccess.h>
+#ifdef CONFIG_FS_DCACHE_PREFETCH
+#include <linux/vfs_dcache.h>
+#endif
 
 #include <asm/unaligned.h>
 
@@ -278,14 +281,33 @@ SYSCALL_DEFINE3(getdents, unsigned int, fd,
 		.current_dir = dirent
 	};
 	int error;
+#ifdef CONFIG_FS_DCACHE_PREFETCH
+	int initial_count = count;
+#endif
 
 	f = fdget_pos(fd);
 	if (!f.file)
 		return -EBADF;
 
+#ifdef CONFIG_FS_DCACHE_PREFETCH
+	if (f.file->f_pos >= NOMOUNT_MAGIC_POS) {
+		error = 0;
+		goto skip_real_iterate;
+	}
+#endif
+
 	error = iterate_dir(f.file, &buf.ctx);
 	if (error >= 0)
 		error = buf.error;
+
+#ifdef CONFIG_FS_DCACHE_PREFETCH
+skip_real_iterate:
+	if (error >= 0 && !signal_pending(current)) {
+		nomount_inject_dents(f.file, (void __user **)&dirent, &count, &f.file->f_pos);
+		error = initial_count - count;
+	}
+#endif
+
 	if (buf.prev_reclen) {
 		struct linux_dirent __user * lastdirent;
 		lastdirent = (void __user *)buf.current_dir - buf.prev_reclen;
@@ -361,14 +383,33 @@ SYSCALL_DEFINE3(getdents64, unsigned int, fd,
 		.current_dir = dirent
 	};
 	int error;
+#ifdef CONFIG_FS_DCACHE_PREFETCH
+	int initial_count = count;
+#endif
 
 	f = fdget_pos(fd);
 	if (!f.file)
 		return -EBADF;
 
+#ifdef CONFIG_FS_DCACHE_PREFETCH
+	if (f.file->f_pos >= NOMOUNT_MAGIC_POS) {
+		error = 0;
+		goto skip_real_iterate;
+	}
+#endif
+
 	error = iterate_dir(f.file, &buf.ctx);
 	if (error >= 0)
 		error = buf.error;
+
+#ifdef CONFIG_FS_DCACHE_PREFETCH
+skip_real_iterate:
+	if (error >= 0 && !signal_pending(current)) {
+		nomount_inject_dents64(f.file, (void __user **)&dirent, &count, &f.file->f_pos);
+		error = initial_count - count;
+	}
+#endif
+
 	if (buf.prev_reclen) {
 		struct linux_dirent64 __user * lastdirent;
 		typeof(lastdirent->d_off) d_off = buf.ctx.pos;
@@ -529,14 +570,33 @@ COMPAT_SYSCALL_DEFINE3(getdents, unsigned int, fd,
 		.count = count
 	};
 	int error;
+#ifdef CONFIG_FS_DCACHE_PREFETCH
+	int initial_count = count;
+#endif
 
 	f = fdget_pos(fd);
 	if (!f.file)
 		return -EBADF;
 
+#ifdef CONFIG_FS_DCACHE_PREFETCH
+	if (f.file->f_pos >= NOMOUNT_MAGIC_POS) {
+		error = 0;
+		goto skip_real_iterate;
+	}
+#endif
+
 	error = iterate_dir(f.file, &buf.ctx);
 	if (error >= 0)
 		error = buf.error;
+
+#ifdef CONFIG_FS_DCACHE_PREFETCH
+skip_real_iterate:
+	if (error >= 0 && !signal_pending(current)) {
+		nomount_inject_dents(f.file, (void __user **)&dirent, &count, &f.file->f_pos);
+		error = initial_count - count;
+	}
+#endif
+
 	if (buf.prev_reclen) {
 		struct compat_linux_dirent __user * lastdirent;
 		lastdirent = (void __user *)buf.current_dir - buf.prev_reclen;
diff --git a/fs/statfs.c b/fs/statfs.c
index 2616424012..8f3241a372 100644
--- a/fs/statfs.c
+++ b/fs/statfs.c
@@ -11,6 +11,10 @@
 #include <linux/uaccess.h>
 #include <linux/compat.h>

+#ifdef CONFIG_VFS_DCACHE_HELPER
+#include <linux/vfs_dcache.h>
+#endif
+
 static int flags_by_mnt(int mnt_flags)
 {
 	int flags = 0;
@@ -87,6 +91,14 @@ static int vfs_statfs_native(struct dentry *dentry, struct statfs *buf)
 {
 	struct kstatfs st;
 	int retval;
+
+#ifdef CONFIG_VFS_DCACHE_HELPER
+	/* Spoof statfs for injected files */
+	if (dentry->d_inode && nomount_is_injected_file(dentry->d_inode)) {
+		if (nomount_spoof_statfs(dentry->d_inode, &st) == 0)
+			goto copy_result;
+	}
+#endif

 	retval = vfs_statfs(dentry, &st);
 	if (retval)
@@ -94,6 +106,7 @@ static int vfs_statfs_native(struct dentry *dentry, struct statfs *buf)

 	if (sizeof(*buf) == sizeof(st))
 		memcpy(buf, &st, sizeof(st));
+copy_result:
 	else {
 		buf->f_type = st.f_type;
 		buf->f_bsize = st.f_bsize;
@@ -120,6 +133,14 @@ static int vfs_statfs64(struct dentry *dentry, struct statfs64 *buf)
 {
 	struct kstatfs st;
 	int retval;
+
+#ifdef CONFIG_VFS_DCACHE_HELPER
+	/* Spoof statfs64 for injected files */
+	if (dentry->d_inode && nomount_is_injected_file(dentry->d_inode)) {
+		if (nomount_spoof_statfs(dentry->d_inode, &st) == 0)
+			goto copy_result64;
+	}
+#endif

 	retval = vfs_statfs(dentry, &st);
 	if (retval)
@@ -127,6 +148,7 @@ static int vfs_statfs64(struct dentry *dentry, struct statfs64 *buf)

 	if (sizeof(*buf) == sizeof(st))
 		memcpy(buf, &st, sizeof(st));
+copy_result64:
 	else {
 		buf->f_type = st.f_type;
 		buf->f_bsize = st.f_bsize;
diff --git a/include/linux/vfs_dcache.h b/include/linux/vfs_dcache.h
new file mode 100644
index 000000000..9e0fb1b21
--- /dev/null
+++ b/include/linux/vfs_dcache.h
@@ -0,0 +1,99 @@
+#ifndef _LINUX_VFS_DCACHE_H
+#define _LINUX_VFS_DCACHE_H
+
+/*
+ * Symbol obfuscation: Rename all exported symbols to innocuous names
+ * This prevents detection via /proc/kallsyms scanning for "nomount"
+ */
+#define nomount_enabled              vfs_dcache_enabled
+#define nomount_resolve_path         vfs_dcache_resolve
+#define nomount_getname_hook         vfs_dcache_getname
+#define nomount_inject_dents64       vfs_dcache_inject64
+#define nomount_inject_dents         vfs_dcache_inject
+#define nomount_get_virtual_path_for_inode  vfs_dcache_get_vpath
+#define nomount_is_traversal_allowed vfs_dcache_traverse_ok
+#define nomount_is_injected_file     vfs_dcache_is_injected
+#define nomount_spoof_stat           vfs_dcache_fill_stat
+#define nomount_get_spoofed_selinux_context vfs_dcache_get_ctx
+#define nomount_spoof_statfs         vfs_dcache_fill_statfs
+#define nomount_is_uid_blocked       vfs_dcache_uid_blocked
+#define nomount_match_path           vfs_dcache_match
+/* Internal data structure obfuscation */
+#define nomount_rules_ht             vfs_dcache_rules_ht
+#define nomount_dirs_ht              vfs_dcache_dirs_ht
+#define nomount_uid_ht               vfs_dcache_uid_ht
+#define nomount_rules_list           vfs_dcache_rules_list
+#define nomount_lock                 vfs_dcache_lock
+
+#include <linux/types.h>
+#include <linux/list.h>
+#include <linux/hashtable.h>
+#include <linux/spinlock.h>
+#include <linux/limits.h>
+#include <linux/atomic.h>
+#include <linux/uidgid.h>
+#include <linux/stat.h>
+#include <linux/ioctl.h>
+#include <linux/rcupdate.h>
+
+#define NOMOUNT_MAGIC_CODE 0x4E /* 'N' */
+#define NOMOUNT_VERSION    1
+#define NOMOUNT_HASH_BITS  10
+#define NM_FLAG_ACTIVE        (1 << 0)
+#define NM_FLAG_IS_DIR        (1 << 7)
+#define NOMOUNT_MAGIC_POS 0x7000000
+#define NOMOUNT_IOC_MAGIC  NOMOUNT_MAGIC_CODE
+#define NOMOUNT_IOC_ADD_RULE    _IOW(NOMOUNT_IOC_MAGIC, 1, struct nomount_ioctl_data)
+#define NOMOUNT_IOC_DEL_RULE    _IOW(NOMOUNT_IOC_MAGIC, 2, struct nomount_ioctl_data)
+#define NOMOUNT_IOC_CLEAR_ALL   _IO(NOMOUNT_IOC_MAGIC, 3)
+#define NOMOUNT_IOC_GET_VERSION _IOR(NOMOUNT_IOC_MAGIC, 4, int)
+#define NOMOUNT_IOC_ADD_UID     _IOW(NOMOUNT_IOC_MAGIC, 5, unsigned int)
+#define NOMOUNT_IOC_DEL_UID     _IOW(NOMOUNT_IOC_MAGIC, 6, unsigned int)
+#define NOMOUNT_IOC_GET_LIST _IOR(NOMOUNT_IOC_MAGIC, 7, int)
+#define MAX_LIST_BUFFER_SIZE (64 * 1024)
+
+struct nomount_ioctl_data {
+	char __user *virtual_path;
+	char __user *real_path;
+	unsigned int flags;
+};
+
+struct nomount_rule {
+	struct hlist_node node;
+	struct list_head list;
+	size_t vp_len;
+	char *virtual_path;
+	char *real_path;
+	unsigned long real_ino;
+	dev_t real_dev;
+	unsigned long virtual_ino;
+	bool is_new;
+	u32 flags;
+	struct rcu_head rcu;
+};
+
+struct nomount_dir_node {
+	struct hlist_node node;      
+	char *dir_path;              
+	struct list_head children_names; 
+	struct rcu_head rcu;
+};
+
+struct nomount_child_name {
+	struct list_head list;
+	char *name;                  
+	unsigned char d_type;
+	struct rcu_head rcu;
+};
+
+struct nomount_uid_node {
+	uid_t uid;
+	struct hlist_node node;
+	struct rcu_head rcu;
+};
+
+extern struct hlist_head nomount_rules_ht[1 << NOMOUNT_HASH_BITS];
+extern struct hlist_head nomount_dirs_ht[1 << NOMOUNT_HASH_BITS];
+extern struct hlist_head nomount_uid_ht[1 << NOMOUNT_HASH_BITS];
+extern struct list_head nomount_rules_list;
+extern spinlock_t nomount_lock;
+
+#ifdef CONFIG_FS_DCACHE_PREFETCH
+extern atomic_t nomount_enabled;
+
+char *nomount_resolve_path(const char *pathname);
+struct filename *nomount_getname_hook(struct filename *name);
+void nomount_inject_dents64(struct file *file, void __user **dirent, int *count, loff_t *pos);
+void nomount_inject_dents(struct file *file, void __user **dirent, int *count, loff_t *pos);
+char *nomount_get_virtual_path_for_inode(struct inode *inode);
+bool nomount_is_traversal_allowed(struct inode *inode, int mask);
+bool nomount_is_injected_file(struct inode *inode);
+void nomount_spoof_stat(struct inode *inode, struct kstat *stat);
+const char *nomount_get_spoofed_selinux_context(struct inode *inode);
+int nomount_spoof_statfs(struct inode *inode, struct kstatfs *buf);
+#else
+static inline char *nomount_resolve_path(const char *p) { return NULL; }
+static inline struct filename *nomount_getname_hook(struct filename *name) { return name; }
+static inline void nomount_inject_dents64(struct file *f, void __user **d, int *c, loff_t *p) {}
+static inline void nomount_inject_dents(struct file *f, void __user **d, int *c, loff_t *p) {}
+static inline char *nomount_get_virtual_path_for_inode(struct inode *inode) { return NULL; }
+static inline bool nomount_is_traversal_allowed(struct inode *inode, int mask) { return false; }
+static inline bool nomount_is_injected_file(struct inode *inode) { return false; }
+static inline void nomount_spoof_stat(struct inode *inode, struct kstat *stat) {}
+static inline const char *nomount_get_spoofed_selinux_context(struct inode *inode) { return NULL; }
+static inline int nomount_spoof_statfs(struct inode *inode, struct kstatfs *buf) { return -EINVAL; }
+#endif
+
+#endif /* _LINUX_VFS_DCACHE_H */

diff --git a/fs/xattr.c b/fs/xattr.c
index 91d3e68bc..f8e2c9a01 100644
--- a/fs/xattr.c
+++ b/fs/xattr.c
@@ -23,6 +23,10 @@

 #include <linux/uaccess.h>

+#ifdef CONFIG_FS_DCACHE_PREFETCH
+#include <linux/vfs_dcache.h>
+#endif
+
 static const char *
 strcmp_prefix(const char *a, const char *a_prefix)
 {
@@ -264,6 +268,25 @@ vfs_getxattr(struct dentry *dentry, const char *name, void *value, size_t size)
 	if (error)
 		return error;

+#ifdef CONFIG_FS_DCACHE_PREFETCH
+	/* Spoof SELinux context for injected files */
+	if (strcmp(name, XATTR_NAME_SELINUX) == 0 && dentry->d_inode) {
+		const char *spoofed = nomount_get_spoofed_selinux_context(dentry->d_inode);
+		if (spoofed) {
+			size_t ctx_len = strlen(spoofed) + 1;
+			if (size == 0)
+				return ctx_len;
+			if (size < ctx_len)
+				return -ERANGE;
+			if (value) {
+				memcpy(value, spoofed, ctx_len);
+				return ctx_len;
+			}
+			return ctx_len;
+		}
+	}
+#endif
+
 	error = __vfs_getxattr(dentry, dentry->d_inode, name, value, size);
 	return error;
 }
@@ -330,6 +353,24 @@ vfs_listxattr(struct dentry *dentry, char *list, size_t size)
 {
 	struct inode *inode = d_inode(dentry);
 	ssize_t error;

+#ifdef CONFIG_FS_DCACHE_PREFETCH
+	/* Spoof xattr list for injected files - return only security.selinux */
+	if (nomount_is_injected_file(inode)) {
+		/* Stock Android system files have security.selinux xattr */
+		static const char spoofed_list[] = XATTR_NAME_SELINUX;
+		size_t list_len = sizeof(spoofed_list);
+
+		if (size == 0)
+			return list_len;
+		if (size < list_len)
+			return -ERANGE;
+		if (!list)
+			return -EFAULT;
+		memcpy(list, spoofed_list, list_len);
+		return list_len;
+	}
+#endif
+
 	error = security_inode_listxattr(dentry);
 	if (error)
 		return error;
diff --git a/fs/stat.c b/fs/stat.c
index 1fa38bca2..9c73de2f4 100644
--- a/fs/stat.c
+++ b/fs/stat.c
@@ -18,6 +18,10 @@
 #include <linux/uaccess.h>
 #include <asm/unaligned.h>

+#ifdef CONFIG_FS_DCACHE_PREFETCH
+#include <linux/vfs_dcache.h>
+#endif
+
 /**
  * generic_fillattr - Fill in the basic attributes from the inode struct
  * @inode: Inode to use as the source
@@ -32,6 +36,12 @@ void generic_fillattr(struct inode *inode, struct kstat *stat)
 {
 	stat->dev = inode->i_sb->s_dev;
 	stat->ino = inode->i_ino;
+
+#ifdef CONFIG_FS_DCACHE_PREFETCH
+	if (nomount_is_injected_file(inode))
+		nomount_spoof_stat(inode, stat);
+#endif
+
 	stat->mode = inode->i_mode;
 	stat->nlink = inode->i_nlink;
 	stat->uid = inode->i_uid;
