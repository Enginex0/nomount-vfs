--- a/fs/vfs_dcache.c	2026-01-24 10:28:03.433189267 +0100
+++ b/fs/vfs_dcache.c	2026-01-24 10:29:12.214443450 +0100
@@ -981,9 +981,19 @@
 			spin_lock(&nomount_lock);
 			hash_for_each_rcu(nomount_rules_ht, bkt, rule, node) {
 				if (rule->real_path && strcmp(rule->real_path, rpath) == 0 &&
-				    rule->real_ino == 0) {
-					rule->real_ino = resolved_ino;
-					rule->real_dev = resolved_dev;
+				    READ_ONCE(rule->real_ino) == 0) {
+					/* Memory barrier ensures real_dev written before real_ino.
+					 * Readers check real_ino first (non-zero = resolved), so
+					 * this ordering prevents seeing valid ino with stale dev
+					 * (data race on ARM64 due to weak memory ordering).
+					 *
+					 * Write order: real_dev -> barrier -> real_ino
+					 * Read order: real_ino (if non-zero) -> real_dev is valid
+					 */
+					WRITE_ONCE(rule->real_dev, resolved_dev);
+					smp_wmb();  /* Write memory barrier */
+					WRITE_ONCE(rule->real_ino, resolved_ino);
+
 					pr_info("nomount: [LAZY_RESOLVE] %s -> ino=%lu dev=%u:%u\n",
 						rpath, resolved_ino, MAJOR(resolved_dev), MINOR(resolved_dev));
 					break;
