--- a/fs/vfs_dcache.c	2026-01-24 10:27:38.133947736 +0100
+++ b/fs/vfs_dcache.c	2026-01-24 10:28:03.433189267 +0100
@@ -472,6 +472,9 @@
 		if (paths) {
 			i = 0;
 			list_for_each_entry(rule, &nomount_rules_list, list) {
+				/* Prevent buffer overflow if list grew between count and copy */
+				if (i >= count)
+					break;
 				if (i < count)
 					paths[i++] = kstrdup(rule->virtual_path, GFP_ATOMIC);
 			}
@@ -557,6 +560,15 @@
 
 			ret = kern_path(parent_path, LOOKUP_FOLLOW, &vpath);
 			if (ret == 0) {
+				/* Verify kern_path() returned valid mount/dentry/sb */
+				if (!vpath.mnt || !vpath.dentry || !vpath.dentry->d_sb) {
+					NM_DBG("cache_metadata: kern_path succeeded but invalid vpath components (mnt=%p dentry=%p sb=%p)\n",
+						vpath.mnt, vpath.dentry, vpath.dentry ? vpath.dentry->d_sb : NULL);
+					path_put(&vpath);
+					parent_depth++;
+					continue;
+				}
+
 				/* Found existing parent! Cache its statfs */
 				rule->cached_partition_dev = vpath.dentry->d_sb->s_dev;
 				mnt_path.mnt = vpath.mnt;
@@ -639,6 +651,12 @@
 	char *found_path = NULL;
 
 	if (!inode || NOMOUNT_DISABLED()) return NULL;
+	if (!inode->i_sb) {
+		/* Pseudo-files (pipes, sockets, devices) have no superblock */
+		NM_DBG("get_vpath: null i_sb for inode=%p, skipping\n", inode);
+		return NULL;
+	}
+
 	if (nomount_is_uid_blocked(current_uid().val)) return NULL;
 	NOMOUNT_HOOK_ENTER_RET(NULL);  /* Recursion guard */
 
@@ -956,7 +974,7 @@
 		return;
 
 	if (kern_path(rpath, LOOKUP_FOLLOW, &path) == 0) {
-		if (path.dentry && d_backing_inode(path.dentry)) {
+		if (path.dentry && path.dentry->d_sb && d_backing_inode(path.dentry)) {
 			ino_t resolved_ino = d_backing_inode(path.dentry)->i_ino;
 			dev_t resolved_dev = path.dentry->d_sb->s_dev;
 
@@ -972,6 +990,8 @@
 				}
 			}
 			spin_unlock(&nomount_lock);
+		} else {
+			NM_DBG("lazy_resolve: kern_path succeeded but invalid components for %s\n", rpath);
 		}
 		path_put(&path);
 	}
