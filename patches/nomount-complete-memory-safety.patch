--- a/fs/vfs_dcache.c
+++ b/fs/vfs_dcache.c
@@ -641,6 +641,12 @@ char *nomount_get_virtual_path_for_inode(struct inode *inode) {
 	char *found_path = NULL;

 	if (!inode || NOMOUNT_DISABLED()) return NULL;
+	if (!inode->i_sb) {
+		/* Pseudo-files (pipes, sockets, devices) have no superblock */
+		NM_DBG("get_vpath: null i_sb for inode=%p, skipping\n", inode);
+		return NULL;
+	}
 	if (nomount_is_uid_blocked(current_uid().val)) return NULL;
 	NOMOUNT_HOOK_ENTER_RET(NULL);  /* Recursion guard */

@@ -471,7 +477,10 @@ static void nomount_force_refresh_all(void) {
 		if (paths) {
 			i = 0;
 			list_for_each_entry(rule, &nomount_rules_list, list) {
-				if (i < count)
+				/* Prevent buffer overflow if list grew between count and copy */
+				if (i >= count)
+					break;
+				if (i < count)
 					paths[i++] = kstrdup(rule->virtual_path, GFP_ATOMIC);
 			}
 		}
@@ -558,6 +567,15 @@ static int nomount_cache_partition_metadata(struct nomount_rule *rule)

 		ret = kern_path(parent_path, LOOKUP_FOLLOW, &vpath);
 		if (ret == 0) {
+			/* Verify kern_path() returned valid mount/dentry/sb */
+			if (!vpath.mnt || !vpath.dentry || !vpath.dentry->d_sb) {
+				NM_DBG("cache_metadata: kern_path succeeded but invalid vpath components (mnt=%p dentry=%p sb=%p)\n",
+					vpath.mnt, vpath.dentry, vpath.dentry ? vpath.dentry->d_sb : NULL);
+				path_put(&vpath);
+				parent_depth++;
+				continue;
+			}
+
 			/* Found existing parent! Cache its statfs */
 			rule->cached_partition_dev = vpath.dentry->d_sb->s_dev;
 			mnt_path.mnt = vpath.mnt;
@@ -952,7 +970,11 @@ static void nomount_lazy_resolve_real_ino(void)
 		return;

 	if (kern_path(rpath, LOOKUP_FOLLOW, &path) == 0) {
-		if (path.dentry && d_backing_inode(path.dentry)) {
+		/* Verify all pointer components are valid before dereferencing */
+		if (path.dentry && path.dentry->d_sb && d_backing_inode(path.dentry)) {
 			ino_t resolved_ino = d_backing_inode(path.dentry)->i_ino;
 			dev_t resolved_dev = path.dentry->d_sb->s_dev;
+		} else {
+			NM_DBG("lazy_resolve: kern_path succeeded but invalid components for %s\n", rpath);
 		}
 		path_put(&path);
 	}
@@ -1318,6 +1340,12 @@ void nomount_syscall_spoof_stat(int dfd, const char __user *filename, struct ks
 		return;

 	len = strncpy_from_user(pathbuf, filename, sizeof(pathbuf));
+	if (len < 0) {
+		/* Copy from userspace failed - invalid pointer */
+		NM_ERR("syscall_spoof_stat: strncpy_from_user failed (err=%ld) for filename=%p\n",
+			len, filename);
+		return;
+	}
 	pathbuf[sizeof(pathbuf) - 1] = '\0';

 	path = nomount_normalize_path(pathbuf);
